import cv2
import numpy as np
import math
from typing import List, Tuple, Dict

class SearchAndRescueGame:
    def __init__(self):
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –¥–ª—è —Ç—Ä–µ—Ö –æ–±–ª–∞—Å—Ç–µ–π –ø–æ–∏—Å–∫–∞
        self.areas = ['Area A', 'Area B', 'Area C']
        self.prior_probabilities = [0.4, 0.35, 0.25]  # –ù–∞—á–∞–ª—å–Ω—ã–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
        self.sep_values = [0.85, 0.85, 0.85]  # Search Effectiveness Probability
        
        # –ü–æ–∑–∏—Ü–∏–∏ –æ–±–ª–∞—Å—Ç–µ–π –Ω–∞ –∫–∞—Ä—Ç–µ (x, y, width, height)
        self.area_positions = {
            'Area A': (100, 150, 200, 150),
            'Area B': (350, 100, 200, 200),
            'Area C': (200, 350, 250, 150)
        }
        
        # –ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–≤–µ—Å—Ç–Ω–æ–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ
        self.last_known_position = (300, 200)
        self.found_position = None
        self.days_passed = 0
        self.max_days = 3
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã
        self.map = self.create_map()
        
    def create_map(self) -> np.ndarray:
        """–°–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã –º—ã—Å–∞ Python —Å –æ–±–ª–∞—Å—Ç—è–º–∏ –ø–æ–∏—Å–∫–∞"""
        # –°–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –º–æ—Ä—è
        map_img = np.ones((600, 800, 3), dtype=np.uint8) * 255
        
        # –†–∏—Å–æ–≤–∞–Ω–∏–µ –±–µ—Ä–µ–≥–æ–≤–æ–π –ª–∏–Ω–∏–∏
        points = np.array([[0, 400], [200, 350], [400, 380], [600, 300], [800, 350], 
                          [800, 600], [600, 550], [400, 500], [200, 550], [0, 500]], np.int32)
        cv2.fillPoly(map_img, [points], (200, 230, 255))
        
        # –†–∏—Å–æ–≤–∞–Ω–∏–µ –æ–±–ª–∞—Å—Ç–µ–π –ø–æ–∏—Å–∫–∞
        colors = [(255, 200, 200), (200, 255, 200), (200, 200, 255)]
        for i, (area, (x, y, w, h)) in enumerate(self.area_positions.items()):
            cv2.rectangle(map_img, (x, y), (x + w, y + h), colors[i], 2)
            cv2.putText(map_img, area, (x + 10, y + 30), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, colors[i], 2)
            
        # –ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–≤–µ—Å—Ç–Ω–æ–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ
        cv2.circle(map_img, self.last_known_position, 10, (0, 0, 255), -1)
        cv2.putText(map_img, "Last Known", 
                   (self.last_known_position[0] - 40, self.last_known_position[1] - 15),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)
        
        return map_img
    
    def bayes_update(self, area_index: int, search_success: bool) -> None:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ç–µ–æ—Ä–µ–º—ã –ë–∞–π–µ—Å–∞"""
        sep = self.sep_values[area_index]
        prior = self.prior_probabilities[area_index]
        
        if search_success:
            # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏
            new_prob = (sep * prior) / (sep * prior)
            # –û–±–Ω—É–ª—è–µ–º –¥—Ä—É–≥–∏–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
            for i in range(len(self.prior_probabilities)):
                if i == area_index:
                    self.prior_probabilities[i] = 1.0
                else:
                    self.prior_probabilities[i] = 0.0
        else:
            # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ - –ø—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–æ—Ä–µ–º—É –ë–∞–π–µ—Å–∞
            p_not_found_given_present = 1 - sep
            p_not_found = (p_not_found_given_present * prior) + (1 - prior)
            
            new_prob = (p_not_found_given_present * prior) / p_not_found
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –¥–ª—è –ø–æ–∏—Å–∫–æ–≤–æ–π –æ–±–ª–∞—Å—Ç–∏
            self.prior_probabilities[area_index] = new_prob
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
            total_remaining = sum(self.prior_probabilities)
            for i in range(len(self.prior_probabilities)):
                if i != area_index:
                    self.prior_probabilities[i] /= total_remaining
    
    def search_area(self, area_index: int, search_quality: float) -> bool:
        """–ü–æ–∏—Å–∫ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏"""
        if area_index < 0 or area_index >= len(self.areas):
            return False
            
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –ø–æ–∏—Å–∫–∞
        original_sep = self.sep_values[area_index]
        self.sep_values[area_index] = search_quality
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω–∞–π–¥–µ–Ω –ª–∏ –º–æ—Ä—è–∫ (–æ—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏)
        actual_presence_prob = self.prior_probabilities[area_index]
        found = np.random.random() < actual_presence_prob * search_quality
        
        if found:
            # –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ–±–ª–∞—Å—Ç–∏ –ø–æ–∏—Å–∫–∞
            x, y, w, h = self.area_positions[self.areas[area_index]]
            self.found_position = (x + np.random.randint(w//4, 3*w//4), 
                                 y + np.random.randint(h//4, 3*h//4))
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –ë–∞–π–µ—Å–∞
        self.bayes_update(area_index, found)
        
        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ SEP
        self.sep_values[area_index] = original_sep
        
        return found
    
    def display_status(self) -> np.ndarray:
        """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ –Ω–∞ –∫–∞—Ä—Ç–µ"""
        display_map = self.map.copy()
        
        # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π
        y_offset = 30
        for i, area in enumerate(self.areas):
            prob_text = f"{area}: {self.prior_probabilities[i]:.1%}"
            color = (0, 0, 0) if self.prior_probabilities[i] < 0.5 else (0, 0, 255)
            cv2.putText(display_map, prob_text, (10, y_offset), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
            y_offset += 25
        
        # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ—à–µ–¥—à–∏—Ö –¥–Ω–µ–π
        days_text = f"Day: {self.days_passed}/{self.max_days}"
        cv2.putText(display_map, days_text, (650, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 0), 2)
        
        # –ï—Å–ª–∏ –º–æ—Ä—è–∫ –Ω–∞–π–¥–µ–Ω
        if self.found_position:
            cv2.circle(display_map, self.found_position, 15, (0, 255, 0), -1)
            cv2.putText(display_map, "FOUND!", 
                       (self.found_position[0] - 30, self.found_position[1] - 20),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        
        return display_map
    
    def run_game(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª"""
        print("=== SEARCH AND RESCUE GAME ===")
        print("Find the lost sailor near Cape Python!")
        print("You can search 2 areas per day.")
        print("Search quality: 1.0 = perfect, 0.2 = poor")
        print("\nAreas: A, B, C")
        
        while self.days_passed < self.max_days and not self.found_position:
            self.days_passed += 1
            print(f"\n--- DAY {self.days_passed} ---")
            
            searches_today = 0
            while searches_today < 2:
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å
                status_map = self.display_status()
                cv2.imshow('Search and Rescue', status_map)
                cv2.waitKey(100)
                
                print(f"\nCurrent probabilities:")
                for i, area in enumerate(self.areas):
                    print(f"  {area}: {self.prior_probabilities[i]:.1%}")
                
                # –í—ã–±–æ—Ä –æ–±–ª–∞—Å—Ç–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞
                area_choice = input(f"\nSearch {searches_today + 1}/2 - Choose area (A/B/C) or Q to quit: ").upper()
                
                if area_choice == 'Q':
                    cv2.destroyAllWindows()
                    return
                
                area_map = {'A': 0, 'B': 1, 'C': 2}
                if area_choice not in area_map:
                    print("Invalid choice! Use A, B, or C.")
                    continue
                
                area_index = area_map[area_choice]
                
                # –í—ã–±–æ—Ä –∫–∞—á–µ—Å—Ç–≤–∞ –ø–æ–∏—Å–∫–∞
                try:
                    quality = float(input("Search quality (0.2-1.0): "))
                    quality = max(0.2, min(1.0, quality))
                except ValueError:
                    print("Invalid quality! Using default 0.85")
                    quality = 0.85
                
                # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ–∏—Å–∫–∞
                print(f"Searching {self.areas[area_index]} with quality {quality}...")
                found = self.search_area(area_index, quality)
                
                if found:
                    print("üéâ SAILOR FOUND! üéâ")
                    break
                else:
                    print("Sailor not found in this area.")
                    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
                    print("Updated probabilities after search:")
                    for i, area in enumerate(self.areas):
                        print(f"  {area}: {self.prior_probabilities[i]:.1%}")
                
                searches_today += 1
            
            if self.found_position:
                break
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã –≤ –∫–æ–Ω—Ü–µ –¥–Ω—è
            status_map = self.display_status()
            cv2.imshow('Search and Rescue', status_map)
            cv2.waitKey(1000)
        
        # –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        final_map = self.display_status()
        cv2.imshow('Search and Rescue', final_map)
        
        if self.found_position:
            print(f"\nüéâ MISSION SUCCESS! Sailor found on day {self.days_passed}!")
            print("The sailor has been rescued!")
        else:
            print(f"\nüíî MISSION FAILED! Sailor not found within {self.max_days} days.")
            print("The probabilities were:")
            for i, area in enumerate(self.areas):
                print(f"  {area}: {self.prior_probabilities[i]:.1%}")
        
        print("\nPress any key to exit...")
        cv2.waitKey(0)
        cv2.destroyAllWindows()

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    print("Initializing Search and Rescue Game...")
    game = SearchAndRescueGame()
    game.run_game()

if __name__ == "__main__":
    main()
